Yes, you can add JWT authentication to your application by using a library such as PyJWT. Here's an example of how you can add JWT authentication to your routes:

Install PyJWT by running pip install pyjwt
Import the library at the top of your file: import jwt
Create a secret key that will be used to encode and decode the JWT tokens. You can store this in a separate file or hardcode it in your application:
Copy code
SECRET_KEY = 'yoursecretkey'
In the /upload and /create routes, before any other logic, add a check to see if the user has included a valid JWT token in their request. You can use the jwt.decode() method to decode the token and verify that it is valid.
Copy code
    # inside the route
    auth_header = request.headers.get('Authorization')
    if auth_header:
        token = auth_header.split(" ")[1]
    else:
        return jsonify({"error": "Not authorized"}), 401
    try:
        data = jwt.decode(token, SECRET_KEY)
    except:
        return jsonify({"error": "Not authorized"}), 401
In the /download route you can add an authentication check at the top before the file exists check
Copy code
    auth_header = request.headers.get('Authorization')
    if auth_header:
        token = auth_header.split(" ")[1]
    else:
        return jsonify({"error": "Not authorized"}), 401
    try:
        data = jwt.decode(token, SECRET_KEY)
    except:
        return jsonify({"error": "Not authorized"}), 401
On the client side, you will need to create a JWT token and include it in the Authorization header of the request. You can use the jwt.encode() method to encode the token.
This is a basic example of how you can add JWT authentication to your application. You may need to customize it to fit your specific requirements. Be aware that this example doesn't check the expiration date of the token and you may want to add this feature for better security.

---------------------------

es, you can use JWT with a private key. Instead of a secret key, you will need to use the private key to sign and verify the JWT tokens. Here's how you can update the code to use a private key:

Replace the SECRET_KEY variable with the path to your private key file:
Copy code
PRIVATE_KEY_FILE = 'path/to/private.key'
Use the jwt.encode() method to encode the token, but this time pass the algorithm='RS256' parameter and the private key file.
Copy code
with open(PRIVATE_KEY_FILE, 'r') as private_file:
    private_key = private_file.read()
    token = jwt.encode(payload, private_key, algorithm='RS256')
In order to decode the token, you will need to use the public key file. You can use the jwt.decode() method, but pass the algorithm='RS256' parameter and the public key file.
Copy code
with open(PUBLIC_KEY_FILE, 'r') as public_file:
    public_key = public_file.read()
    data = jwt.decode(token, public_key, algorithms='RS256')
Note that this example assumes that you have a private key file and a public key file, and that you know the path to these files. This is only an example and you should adapt it to your needs.

You can use the same way to decode the token in the /download route

Copy code
    auth_header = request.headers.get('Authorization')
    if auth_header:
        token = auth_header.split(" ")[1]
    else:
        return jsonify({"error": "Not authorized"}), 401
    try:
        with open(PUBLIC_KEY_FILE, 'r') as public_file:
            public_key = public_file.read()
            data = jwt.decode(token, public_key, algorithms='RS256')
    except:
        return jsonify({"error": "Not authorized"}), 401
You should keep your private key secret and make sure it is not exposed in your application, since it is the key used to sign the JWT tokens.

You can use this way to make your JWT tokens more secure.